# -*- coding: utf-8 -*-
"""Debugged.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aeLdNzsLQmudGUbNRQW34tk5qpr9IDx-
"""

import torch
import torch.nn as nn
import torch.optim as optim

# define the function for Celsius to Fahrenheit conversion
def c2f(c):
    return (c * 1.8) + 32

# define the training dataset
train_x = torch.randn(1000)
train_y = c2f(train_x)

# define the test dataset
test_x = torch.randn(100)
test_y = c2f(test_x)

# define the network architecture
class Net(nn.Module):
    def __init__(self):
        super(Net, self).__init__()
        self.fc1 = nn.Linear(1, 10)
        self.fc2 = nn.Linear(10, 1)
    
    def forward(self, x):
        x = torch.relu(self.fc1(x))
        x = self.fc2(x)
        return x

# create the network instance and define the loss function and optimizer
net = Net()
criterion = nn.MSELoss()
optimizer = optim.SGD(net.parameters(), lr=0.01)

# train the network for multiple epochs
for epoch in range(100):
    running_loss = 0.0
    for i in range(1000):
        inputs = train_x[i].unsqueeze(0)
        labels = train_y[i].unsqueeze(0)

        optimizer.zero_grad()
        outputs = net(inputs)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()

        running_loss += loss.item()

    # print the training loss after every epoch
    if epoch % 100 == 0:
        print("Epoch {} - Training Loss: {}".format(epoch, running_loss / 1000))

# test the network on the test dataset and print the test loss
test_inputs = test_x.unsqueeze(1)
test_labels = test_y.unsqueeze(1)
test_outputs = net(test_inputs)
test_loss = criterion(test_outputs, test_labels)
print("Test Loss: {}".format(test_loss.item()))

# check if the model has learned the parameters
assert abs(c2f(0) - net(torch.tensor([0.0])).item()) < 0.1, "Model didn't learn the parameters"